# JavaScript面试题

## 基础

### 闭包

JavaScript 中有全局作用域、函数作用域和块级作用域。一般情况下，函数作用域内声明的变量函数在函数外部无法访问。可以通过在函数内部再定义一个内部函数，并把它作为返回值，这样在函数外部就可以通过这个内部函数访问函数内的变量了，这个内部函数就是闭包。

### 原型和原型链

每个函数都有一个 `prototype` 属性，该属性指向一个对象。把这个函数作为构造函数，生成的实例对象有个隐藏属性 `__proto__` ，这个属性也会指向这个对象，这个对象就是实例对象的原型。

原型也是一个对象，它也有原型，它的 `__proto__` 隐藏属性指向 `Object.prototype`。这样通过 `__proto__` 连接的原型就组成了原型链。

### 继承

结合构造函数和原型模式创建类，将私有的方法的方法和属性放在构造函数中，将公有的属性和方法放在原型中。

JavaScript 通过原型实现类的继承。继承方式有：原型链继承、借用构造函数继承、组合继承 、寄生组合继承。

组合继承是结合原型链继承和借用构造函数继承。把子类的原型指向父类的实例，把子类原型的constructor指回子类构造函数，再在子类的构造函数中调用父类的构造函数，实现继承。缺点是调用了两次父类构造函数。

寄生组合继承是通过 Object.create() 把子类的原型直接指向父类的原型，少调用一次父类，同时也要把子类原型的constructor 指回子类构造函数，再在子类的构造函数中调用父类的构造函数，实现继承。

### 事件循环

## ES6

## 网络

## 框架

### Vue中实现双向数据绑定

Vue 在初始化时会遍历 data 选项中的属性，并用 observer 劫持数据，使用 Object.defineProperty 每个属性添加 getter 和 setter。在 getter 函数中将订阅者 watcher 添加到 dep 订阅器。在 setter 函数中通知订阅者更新。指令编译器 Complie 会深度遍历 DOM 树，对每个元素节点的指令模板进行替换数据以及订阅数据。当数据发生变化是，会触发 setter 方法，setter 会调用 notify() 方法 通知所有的订阅者更新视图。

### computed、watch

computed 计算属性是基于它们的依赖进行缓存。计算属性只有在它的相关依赖发生改变时才会重新求值。

watch 监听复杂数据类型需用深度监听，听对应的函数名必须为 handler。