# 浏览器相关面试题

## 从输入 URL 到展示页面的过程

1. 浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期

2. DNS 解析 URL 对应的 IP

3. 根据 IP 建立 TCP 连接（三次握手）

4. HTTP 发送请求，设置请求报文（请求头、请求体）

5. 服务器处理请求，返回请求的文件，浏览器接收 HTTP 响应

6. 浏览器解析渲染页面

    + 解析 HTML 生成 DOM 树

    + 解析 CSS 生成 css 规则树

    + 结合 DOM 树 与 css 规则树，生成渲染树 render 树

    + 布局 render 树（Layout/reflow），负责各元素尺寸/位置的计算

    + 绘制 render 树（print），绘制页面像素信息

    + 浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上

7. 关闭 TCP 连接（四次挥手）

## 浏览器渲染解析页面

1. 根据 HTML 解析 DOM 树

    + 根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点
    + 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕

2. 根据 CSS 解析生成 CSS 规则树

    + 解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪
    + 浏览器在 CSS 规则树生成之前不会进行渲染
    + 越是具体的 CSS 选择器，执行速度越慢

3. 结合 DOM 树和 CSS 规则树，生成渲染树

    + DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树
    + 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度

4. 根据渲染树计算每一个节点的信息（布局）

    + 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸
    + 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染

5. 据计算好的信息绘制页面

    + 绘制阶段，系统会遍历呈现树，并调用呈现器的 “paint” 方法，将呈现器的内容显示在屏幕上
    + 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘
    + 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染

![页面渲染](./img/页面渲染.png)

## 重绘（Repaint）和回流（Reflow）

重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。

+ 重绘：当节点需要更改外观而不会影响布局的，比如改变 color、background-color、visibility等就叫称为重绘
+ 回流：布局或者几何属性需要改变 就称为回流

注意:

+ 回流必定会发生重绘，重绘不一定会引发回流
+ 回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流

会导致回流的操作：

+ 页面首次渲染
+ 浏览器窗口大小发生改变
+ 元素尺寸或位置发生改变
+ 元素内容变化（文字数量或图片大小等等）
+ 元素字体大小变化
+ 添加或者删除可见的 DOM 元素
+ 激活CSS伪类（例如：:hover）
+ 查询某些属性或调用某些方法

减少重绘和回流：

+ 使用 translate 替代 top
+ 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）
+ 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来
+ 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量
+ 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
+ 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame
+ CSS 选择符从右往左匹配查找，避免 DOM 深度过深
+ 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层

  CSS:

  + 避免使用 table 布局
  + 尽可能在 DOM 树的最末端改变 class
  + 避免设置多层内联样式。
  + 将动画效果应用到 position 属性为 absolute 或 fixed 的元素上。
  + 避免使用 CSS 表达式例如：calc()

  JavaScript:

  + 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为 class 并一次性更改class属性
  + 避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中
  + 也可以先为元素设置 display: none，操作结束后再把它显示出来。因为在display属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘
  + 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来
  + 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流

## 浏览器缓存

浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确认的

根据响应头，浏览器缓存策略一般分为三种：强缓存、协商缓存、启发式缓存

浏览器常见字段和指令

+ `Expires`: 告知客户端资源缓存失效的绝对时间
+ `Last-Modified`: 资源最后一次修改的时间
+ `Etag`: 文件的特殊标识
+ `Cache-Control`:告诉客户端或是服务器如何处理缓存

  + `Cache-Control: private`：表示客户端可以缓存
  + `Cache-Control: public` ：表示客户端和代理服务器都可缓存，如果没有明确指定 private，则默认为 public
  + `Cache-Control: no-cache`: 表示需要可以缓存，但每次用应该去向服务器验证缓存是否可用
  + `Cache-Control: no-store`: 表示所有内容都不会缓存，强制缓存，对比缓存都不会触发.
  + `Cache-Control: max-age=xxx`: 表示缓存的内容将在 xxx 秒后失效

自从 HTTP 1.1开始，Expires 逐渐被 Cache-Control 取代。Cache-Control 是一个相对时间，即使客户端时间发生改变，相对时间也不会随之改变，这样可以保持服务器和客户端的时间一致性

![浏览器缓存](./img/浏览器缓存.png)

### 强缓存

强缓存简单理解就是给浏览器缓存设置过期时间，超过这个时间之后缓存就是过期，浏览器需要重新请求

强缓存主要是通过 HTTP 请求头中的 Expires 和 Cache-Control 两个字段控制

Expires 是一个HTTP/1.0的字段，它给浏览器设置了一个绝对时间，当浏览器时间超过这个绝对时间之后，重新向服务器发送请求

+ 它描述的是一个绝对时间，用 GMT 格式的字符串表示

  `Expires: Wed Feb 20 2019 11:25:41 GMT`

+ 也可以在 HTML 文件里直接使用

  `<meta http-equiv="expires" content="Wed Feb 20 2019 11:25:41 GMT">`

+ 弊端：Expires 返回的是服务器的时间，但判断的时候用的却是客户端的时间，因为用户有可能改变客户端的时间，导致缓存时间判断出错，这也是引入Cache-Control:max-age 指令的原因之一

为了解决 Expires 存在的问题，HTTP/1.1 版本中提出了 Cache-Control:max-age

该字段与 Expires 的缓存思路相同，都是设置了一个过期时间，不同的是 max-age 设置的是相对缓存时间开始往后的多少秒，因此不再受日期不准确情况的影响

在优先级上 max-age > Expires，当两者同时出现在响应头时, Expires 将被 max-age覆盖

  `Cache-control: max-age=666` 表示资源会在 666 秒后过期，需要再次请求

### 协商缓存

协商缓存的过程是，先从缓存中获取对应的数据标识，然后向服务器发送请求，确认数据是否更新，如果更新，则返回新数据和新缓存；反之，则返回304状态码，告知客户端缓存未更新，可继续使用

协商缓存主要应用于一些时常需要动态更新的资源文件，解决了无法及时获取更新资源的问题

协商缓存在协议里的字段是 Last-Modified 和 If-Modified-Since

+ `Last-Modified`：服务器告知客户端，资源最后一次被修改的时间