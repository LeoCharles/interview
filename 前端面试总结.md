# 前端面试总结

## CSS 盒模型

- 标准模型：width 为 content，盒子实际宽度为 width、padding、border 的和
- IE 模型：width 为 content、padding border 的总和，因此盒子实际的宽度就为 width

Js 如何设置获取盒模型对应的宽高

- `DOM.style.width/height` (只适用于内联样式)
- `DOM.currentStyle.width/height`(IE 支持)
- `window.getComputedStyle(DOM).widht/height`(chrome、firefox)
- `DOM.getBoundingClientRect().widht/height`

根据盒模型解释边距重叠

## BFC

## DOM 事件

DOM 事件级别

- `DOM0`

  `element.onclick=function(){}`

- `DOM2`

  `element.addEventLister('click', function() {}, false)`

- `DOM3`

  `element.addEventLister('keyup', function() {}， false)`

事件类型：捕获和冒泡

DOM 事件捕获的具体流程：

`window --> document --> html --> body --> 父级元素 --> 目标元素`

DOM 事件冒泡的具体流程：

`目标元素 --> 父级元素 --> body --> html --> document --> window`

Event 对象

`event.preventDefault()`

`event.stopPropagation()`

`event.stopImmediateProgation()`

`event.currentTarget`

`event.target`

## 原型链

- 创建对象的几种方法：

  - 对象字面量
  - 显示的构造函数
  - `Object.create()`

- 原型、构造函数、实例、原型链

JS 对象都有 `__proto__` 属性，这个属性指向了原型，原型的 `constructor` 属性指向构造函数，构造函数又通过 `prototype` 属性指回原型

对象的 `__proto__` 属性指向原型，`__proto__` 将对象和原型连接起来组成了原型链

- `instanceof` 原理

- `new` 运算符

- 继承的方法：

  - 借助构造函数

  - 借助原型链

  - 组合继承（构造函数 + 原型链）

## 通信

- 通信的几种方式：

  - Ajax

  - WebSocket

  - CORS

- 跨域解决方法：

  - jsonp

  - hash

  - postMessage

  - WebSocket

  - CORS

## 浏览器安全

- CSRF：跨站请求伪造

- XSS：跨域脚本攻击

## HTTP 协议

- HTTP 协议的特点：

  - 无连接：TCP 连接一次就会断掉，不会保持连接
  - 无状态：HTTP 协议不会保存客户端的身份
  - 简单快速：每个资源（URI）固定，处理起来简单
  - 灵活：可以在头部设置不同数据类型，完成不同数据传输

- HTTP 报文的组成部分：

  - 请求报文

    - 请求行
    - 请求头
    - 空行
    - 请求体

  - 响应报文

    - 状态行
    - 响应头
    - 空行
    - 响应体

- HTTP 方法：

  - GET ------> 获取资源
  - POST -----> 传输资源
  - PUT ------> 更新资源
  - DELETE ---> 删除资源
  - HEAD -----> 获取报文首部

- POST 和 GET 的区别：

  - GET 在浏览器回退时是无害的，不会再次请求，而 POST 会再次提交请求
  - GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置
  - GET 通过 URL 传参，POST 放在请求体中
  - GET 在 URL 中传参有长度限制（2kb），POST 没有限制
  - GET 请求参数会被完整保留在浏览器历史记录里，POST 的参数不会
  - GET 比 POST 更不安全，因为将参数暴露在 URL 中，因此不能用来传递敏感信息

- HTTP 状态码：

  - 1xx：指示信息 -----> 请求已接收，继续处理

  - 2xx：成功 ---------> 请求已成功被接收

    - 200：OK 客户端请求成功
    - 206：Partial Content 客户端发送了一个带有 Range 头的 GET 请求，服务器完成了它（请求视频、音频资源）

  - 3xx：重定向 -------> 要完成请求必须进一步操作

    - 301：Moved Permanently 永久重定向，所有请求已经转移至新的 URL
    - 302：Found 临时重定向，所请求的页面已经临时转移至新的 URL
    - 304：Not Modified 客户端有缓存的文件，缓存文件还可以继续使用

  - 4xx：客户端错误 ----> 请求有语法错误或请求无法实现

    - 400：Bad Request 客户端有语法错误
    - 401：Unauthorized 请求未经授权
    - 403：Forbidden 访问被禁止
    - 404：Not Found 请求资源不存在

  - 5xx：服务器错误 ----> 服务器未能实现合法的请求
    - 500：Internal Server Error 服务器发生不可预期的错误
    - 503：Server Unavailable 请求未完成，服务器临时过载或宕机

- HTTP 持久连接

HTTP 协议采用 `请求-响应` 模式，当使用普通模式，即非 `keep-Alive` 模式时，每此请求/响应，客户端和服务器都要建立 TCP 连接，请求/响应完成以后立即断开连接（HTTP 协议为无连接的协议）

当使用 `keep-Alive` 模式（又称持久连接）时，客户端到服务器的连接持续有效，当出现后继请求时，避免了重新建立连接

HTTP/1.1 版本才支持持久连接

## 渲染机制

- `DOCTYPE`及作用

`DTD` 用来定义 `XML`、`HTML`的文件类型，浏览器根据它来判断文档类型，决定用何种协议来解析

`DOCTYPE` 是用来声明文档类型和 `DTD`规范的，验证文件的合法性

HTML5: `<!DOCTYPE html>`

浏览器渲染过程

回流 Reflow

重绘 Repaint

布局 Layout

- 优化：
  - 使用 `translate` 替代 `top`
  - 使用 `opacity` 替代 `visibility`
  - 不要一条一条的修改 `DOM` ，要预先定义好 `class`，然后修改 `DOM` 的 `className`
  - 把 `DOM` 离线后修改，比如先把 `DOM` 给 `display:none` (一次回流)，然后修改 100 次，再把它显示出来
  - 不要使用 `table` 布局
  - 对于动画新建图层
  - 启动 `GPU` 加速

## JS 运行机制

- JS 单线程

JS 是单线程，同一时间只能做一件事

- 任务队列

  - 同步任务
  - 异步任务

- Event Loop 事件循环

## 页面性能

提高页面性能的方法：

- 资源压缩合并，减少 HTTP 请求，开启 Gzip 压缩

- 非核心代码异步加载

  - 异步加载方式
    - 动态脚本加载（用 Js 创建 script 标签）
    - defer：在 HTML 解析完之后才会执行，如果是多个，按照加载的顺序依次执行
    - async：在加载完成之后立即执行，如果是多个，执行顺序和加载顺序无关

- 利用浏览器缓存

  - 缓存分类

    - 强缓存
      - Expries
      - Cache-Control
    - 协商缓存
      - Last-Modified If-Modified-Since
      - Etag If-None-Match

  - 缓存原理

- 使用 CDN

- 预解析 DNS

可以通过预解析的方式来预先获得域名所对应的 IP

`<mata http-equiv="x-dns-prefetch-control" content="on"></mata>`

`<link rel="dns-prefetch" href="//host_name_to_prefetch.com"></link>`

## 线上错误监控

- 前端错误分类

  - 即使运行错误（代码错误）
  - 资源加载失败

- 即使运行错误捕获方式

  - `try...catch`
  - `window.onerror`

- 资源加载错误

  - `object.onerror`
  - `preformance.getEntries`
  - `Error`事件捕获

- 上报错误的基本原理

  - 利用 Image 对象上报：`(new Image()).src='http://abc.com/xxx?a=b'`

## 编程题

- 继承

```js
// ES5
function Parent(name) {
  this.name = name
}
function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}
Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child

// ES6
class Parent {
  constructor(name) {
    this.name = name
  }
}
class Child extends Parent {
  constructor(name, age) {
    super(name)
    this.age = age
  }
}
```

- 节流/防抖

```js
// 防抖，延时一段时间再执行函数
function debounce(fn) {
  let timer = null
  return function() {
    clearTimeout(timer)
    timer = setTimeout(() => {
      fn.call(this, arguments)
    }, 1000)
  }
}

// 节流 指定时间间隔内只会执行一次函数
function throttle(fn) {
  let canRun = true
  return function() {
    if (!canRun) {
      return
    }
    canRun = false
    setTimeout(() => {
      fn.call(this, arguments)
      canRun = true
    }, 1000)
  }
}
```

- 数组去重

```js
// 使用 Set 数据结构
function unique(arr) {
  return [...new Set(arr)] // return Array.from(set)
}

// 使用 filter() 和 indexOf()
function unique(arr) {
  return arr.filter((item, index) => {
    return arr.indexOf(item) === index
  })
}

// 使用 includes()
function unique(arr) {
  const newArr = []
  arr.forEach(item => {
    if (!newArr.includes(item)) {
      newArr.push(item)
    }
  })
  return newArr
}

// 先排序，再比较
function unique(arr) {
  const newArr = []
  arr.sort()
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] !== arr[i + 1]) {
      newArr.push(arr[i])
    }
  }
  return newArr
}
```

- 将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

```js
var arr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10]

Array.from(new Set(arr.flat(Infinity))).sort((a, b) => a - b)
```
