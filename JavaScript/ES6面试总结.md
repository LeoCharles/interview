# ES6 总结

## let 与 const

### 块级作用域

ES5 只有全局作用域和函数作用域，ES6 引入块级作用域。块级作用域必须有大括号。

### let 命令

`let` 命令用来声明变量，所声明的变量，只在所在的代码块内有效。

`let` 命令不允许在相同作用域内，重复声明同一个变量。

`let` 命令声明变量后可立即赋值或使用时赋值。

### const 命令

`const` 命令用来声明一个常量，一旦声明，常量的值就不能改变。

`const` 命令所声明的常量，只在所在的块级作用域内有效。

`const` 命令声明常量后必须立即赋值。

### 变量提升

`var` 命令会发生变量提升现象，即变量可以在声明之前使用，值为 `undefined`。

`let` 命令和 `const` 命令不会提升。

### 暂时性死区

在代码块内使用 `let` 命令和 `const` 命令声明变量之前，该变量都不可用，称为暂时性死区（TDZ）。

## 变量的解构赋值

按照一定模式，从数组和对象中提取值，对变量进行赋值，称为解构赋值。

### 解构赋值规则

只要等号两边的模式相同，左边的变量就会被赋予对应的值。

如果等号右边的值不是对象或数组，就先将其转为对象，`undefined` 和 `null` 无法转为对象，因此无法进行解构。

属性值严格等于 `undefined` 时，解构赋值的默认值才会生效。

解构不成功时变量的值等于 `undefined`。

### 解构赋值的用途

交换变量值：`[x, y] = [y, x]`

提取 JSON 数据：`const { id, name } = { id: 1, name: "leo"}`

返回函数多个值：`const [x, y, z] = func() { return [1, 2, 3]}`

定义函数参数：`function func({x, y, z}) { }`

定义函数参数默认值：`function func({ x = 1, y = 2 } = {}) {}`

遍历 Map 结构：`for (let [k, v] of map) {}`

输入模块指定属性和方法：`const { readFile, writeFile } = require("fs")`

## 字符串的扩展

字符串可通过 `for...of` 遍历。

模板字符串，用反引号标识，可以用来定义多行字符串，或者在字符串中嵌入变量。

`matchAll()`：返回正则表达式在字符串的所有匹配。

`includes()`：是否存在参数字符串。

`startsWith()`：参数字符串是否在原字符串的头部。

`endsWith()`：参数字符串是否在原字符串的尾部。

`repeat()`：返回一个新字符串，表示将原字符串重复 n 次。

`padStart()`：用于头部补全长度。

`padEnd()`：用于尾部补全长度。

## 数组的扩展

扩展运算符 `...`，可以将一个数组转为用逗号分隔的参数序列。

克隆数组：`const arr2 = [...arr1]`

合并数组：`const arr = [...arr1, ...arr2]`

拼接数组：`arr.push(...arr1)`

代替函数的 apply 方法：`Math.max.apply(null, [x, y])` 等同于 `Math.max(...[x, y])`

转换字符串为数组：`[..."hello"]`

转换类数组对象为数组：`[...Arguments, ...NodeList]`

转换可遍历对象为数组：`[...String, ...Set, ...Map, ...Generator]`

与数组解构赋值结合：`const [x, ...rest] = [1, 2, 3]`

`Array.from()`：转换具有 `Iterator` 接口的数据结构为真正数组，返回新数组。

`Array.of()`：转换一组值为真正数组，返回新数组。

`find()`：返回第一个符合条件的成员。

`findIndex()`：返回第一个符合条件的成员索引值。

`fill()`：根据指定值填充整个数组，返回原数组。

`includes()`：判断某个数组是否包含给定的值。

`keys()`：返回以键名为遍历器的对象，可以用 `for...of` 循环进行遍历。

`values()`：返回以键值为遍历器的对象，可以用 `for...of` 循环进行遍历。

`entries()`：返回以键值对为遍历器的对象，可以用 `for...of` 循环进行遍历。

## 对象的扩展

`Object.is()`：用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。

`Object.assign()`：用于对象的合并(浅拷贝)，将源对象的所有可枚举属性，复制到目标对象。遇到同名属性会替换。

`Object.getPrototypeOf()`：返回对象的原型对象。

`Object.setPrototypeOf()`：设置对象的原型对象。

`Object.keys()`：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键名。

`Object.values()`：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值。

`Object.entries()`：返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的键值对数组。

对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。

对象的扩展运算符 `...` 用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。

链判断运算符 `?.`，直接在链式调用的时候判断，左侧的对象是否为 `null` 或 `undefined`。如果是的，就不再往下运算，而是返回 `undefined`。

Null 判断运算符 `??` 。它的行为类似 `||`，但是只有运算符左侧的值为 `null` 或 `undefined` 时，才会返回右侧的值。

## 函数的扩展

### 函数的参数

函数的默认参数：直接写在参数定义的后面。

rest 参数：形式为 `...rest`，用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

### 剩余运算符

### 箭头函数

箭头函数体内的 `this` 对象，就是定义时所在作用域的 this 对象。

不可以使用 `arguments` 对象，该对象在函数体内不存在。如果要用，可以用 `rest` 参数代替。

不可以当作构造函数，不可以使用 `new` 命令。

不可以使用 `yield` 命令，因此箭头函数不能用作 `Generator` 函数。

返回对象时必须在对象外面加上括号。

## Symbol

新的原始数据类型，表示独一无二的值。

通过 `Symbol()` 函数生成，可以接受一个字符串作为参数，表示对 `Symbol` 实例的描述。

## Set 和 Map

### Set

新的数据结构 `Set`，类似于数组，但是成员的值都是唯一的，没有重复的值。

`Set()` 函数可以接受一个数组（或者具有 `iterable` 接口的其他数据结构）作为参数，用来初始化。

数组去重的方法：`[...new Set(array)]`

### Map

新的数据结构 `Map`，类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，提供了“值—值”的对应。

## Iterator 遍历器 与 for...of 循环

### Iterator 遍历器接口

遍历器 `Iterator` 是一种接口，为各种不同的数据结构提供统一的访问机制。

任何数据结构只要部署 `Iterator` 接口，就可以完成遍历操作。

### for...of 循环

`for...of` 循环是遍历所有数据结构的统一的方法。一个数据结构只要部署了 `iterator` 接口，就可以用 `for...of` 循环遍历。

数组、Set 和 Map 结构、类数组的对象（arguments、DOM NodeList）、Generator 以及字符串，都可以用 `for...of` 循环遍历。

普通对象不能直接使用 `for...of` 遍历，会报错，必须部署了 `Iterator` 接口后才能使用。

使用 `Object.keys` 方法将对象的键名生成一个数组，然后遍历这个数组。

`for...of` 与 `for...in` 的区别：

`for...in` 循环为遍历对象设计，不适合遍历数组，遍历数组时它以字符串作为键名而不是数字键名，还会遍历原型链上的键。

## Generator 生成器

`Generator` 生成器是一种异步编程解决方案，它可以理解成一个状态机，封装了多个内部状态。

执行 `Generator` 函数会返回一个遍历器对象，返回的遍历器对象，可以依次遍历 `Generator` 函数内部的每一个状态。

`Generator` 函数是有两个特征:

（1）、`function` 关键字与函数名之间有一个星号。

（2）、函数体内部使用`yield` （意思就是“产出”）表达式，定义不同的内部状态。

调用 `Generator` 函数后，返回的是一个遍历器对象（指向内部状态的指针对象），调用遍历器对象的 `next` 方法，使得指针移向下一个状态。

每次调用 `next` 方法，就会返回一个有着 `value` 和 `done` 两个属性的对象。

`value` 属性表示当前的内部状态的值，是 `yield` 表达式后面那个表达式的值；`done` 属性是一个布尔值，表示是否遍历结束。

总之，`Generator` 函数是分段执行的，`yield` 表达式是暂停执行的标记，而 `next` 方法可以恢复执行。

每次调用 `next` 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个`yield` 表达式（或`return` 语句）为止。

## Promise 期约

`Promise` 是异步编程的一种解决方案，可以理解成一个容器，里面保存着异步操作的结果。

`Promise` 对象有三种状态：`pending`（进行中）、`fulfilled`（已成功）和 `rejected`（已失败）。

根据异步操作的结果，可以决定当前是哪一种状态，可以从 `pending` 变为 `fulfilled`，或者从 `pending` 变为 `rejected`，状态一旦改变就不能改变，这时状态就定型了，称为 resolved（已定型）。

`Promise` 构造函数接受一个函数作为参数，该函数的两个参数分别是 `resolve` 和 `reject`。

`resolve` 函数的作用是，将 `Promise` 对象的状态从 `pending` 变为 `resolved`。

`reject` 函数的作用是，将 Promise 对象的状态从 `pending` 变为 `rejected`。

`Promise` 实例生成以后，可以用 `then` 方法分别指定 `resolved` 状态和 `rejected` 状态的回调函数，第一个是状态变为 `resolved` 时调用，第二个参数是状态变为 `rejected` 时调用。

## async 函数

`async` 函数是 `Generator` 函数的语法糖，将 `Generator` 函数的星号（`*`）替换成 `async`，将 `yield` 替换成 `await`。

`async` 函数的返回值是 `Promise` 对象，可以使用 `then` 方法添加回调函数。

## Class 类

通过 `class` 关键字，可以定义类。

类中的 `constructor()` 方法，是构造方法， `this` 关键字则代表实例对象。

定义方法时，前面不需要加上 `function` 关键字，方法与方法之间不需要逗号分隔，加了会报错。

在类的内部可以使用 `get` 和 `set` 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。

在一个方法前，加上 `static` 关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为静态方法。

类可以通过 `extends` 关键字实现继承。 子类必须在 `constructor` 方法中调用 `super()` 方法，否则新建实例时会报错。

ES5 的继承，实质是先创造子类的实例对象 `this`，然后再将父类的方法添加到 `this` 上面（`Parent.apply(this)`）。

ES6 的继承，实质是先将父类实例的属性方法加到 `this` 上(调用 `super()`)，再用子类构造函数修改 `this`。

`super` 关键字，既可以当作函数使用，也可以当作对象使用。

`super` 作为函数调用时，代表父类的构造函数。子类的构造函数必须执行一次 `super` 函数。

`super` 作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类。

## Module 模块

`export` 命令用于规定模块的对外接口。

`import` 命令用于输入其他模块提供的功能。

一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果希望外部能够读取模块内部的某个变量，就必须使用 `export` 关键字输出该变量。

CommonJS 输出值的拷贝，ESM 输出值的引用。

CommonJS 是运行时加载，ESM 是编译时加载。

## Proxy 代理

`Proxy` 用于修改某些操作的默认行为。

`Proxy` 可以理解成，在目标对象之前架设一层拦截，外界对该对象的访问，都必须先通过这层拦截，可以对外界的访问进行过滤和改写。

`const proxy = new Proxy(target, handler);`

target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。

要使 `Proxy` 起作用，必须针对实例进行操作，而不是针对目标对象进行操作。

没有设置任何拦截时，等同于直接通向原对象。

代理下的目标对象，内部 `this` 指向 `Proxy` 代理。

属性被定义为 `不可读写/扩展/配置/枚举` 时，使用拦截方法会报错。

## Reflect 反射

`Reflect` 用于保持 `Object` 方法的默认行为。

将明显属于语言内部的方法（比如Object.defineProperty），放到 `Reflect` 对象上。

让 `Object` 操作变成函数行为。

将某些 `Object` 方法报错情况改成返回 `false`。

`Proxy` 方法和 `Reflect` 方法一一对应。不管 `Proxy` 怎么修改默认行为，总可以在 `Reflect` 上获取默认行为。

`Proxy` 和 `Reflect` 联合使用，前者负责拦截赋值操作，后者负责完成赋值操作。
